# 🛠️ Project PyOS 개발 일지

## 📅 7일 차: 프로세스 시각화 및 개발 일지 시작

### 🎯 오늘의 목표
1. `print(process)` 했을 때 상태가 한눈에 보이게 만들기 (`__repr__` 구현).
2. 개발 과정에서 겪은 시행착오 기록하기.

### 📝 배운 점 (TIL)
* `__str__`과 `__repr__`의 차이점: `__repr__`은 개발자용, 리스트 출력 시 사용됨.
* f-string의 정렬 기능: `f"{val:<10}"` 처럼 쓰면 칸을 맞출 수 있음.

### 💥 트러블 슈팅 (실패와 해결)
* 출력 결과의 세로 줄 어긋남 (정렬 이슈)
현상: 모든 프로세스의 정보가 출력되지만, 남은 시간(Remaining time)이 10인 경우와 5인 경우의 세로 위치가 맞지 않아 표가 삐뚤어짐.

원인: f-string 포맷팅 시 고정된 문자열(Remaining time:)과 가변적인 숫자(5, 10) 사이의 공백 처리가 불분명했기 때문임. 자릿수가 커질수록 숫자가 뒤로 밀리는 현상 발생.

해결: {:>2} 또는 {:>3}과 같은 포맷팅 규칙을 사용하여 **숫자가 들어갈 전용 칸**을 미리 확보함.

메커니즘: 숫자가 1자리든 2자리든 무조건 같은 칸(예: 3칸)을 차지하게 함으로써 뒤에 오는 구분선(|)의 위치를 고정시킴.

Python

수정 전
return f"Remaining time:{self.remaining_time:>2}]" 

수정 후 (공백과 칸 수를 명확히 지정)
return f"Remaining time: {self.remaining_time:>2}]"

💡 깨달은 점
코드에 문제가 없는데 작동하지 않을 때는 **환경(저장 상태, 실행 경로)**을 먼저 의심해 보자.
사용자나 개발자가 보는 데이터는 시각적 정렬이 매우 중요하며, 파이썬의 f-string 정렬 기능은 이를 위한 매우 강력한 도구이다.

## 📅 8일 차: 프로세스 공장 가동 

### 🎯 오늘의 목표
1. 반복문을 이용해 프로세스를 대량 생산하기.
2. `Job Queue`에서 `Ready Queue`로 프로세스를 이동시키는 로직 구현 

### 📝 배운 점 (TIL)
* **`pop(0)` vs `pop()`:** `pop()`은 맨 뒤(스택)에서 꺼내고, `pop(0)`은 맨 앞(큐)에서 꺼낸다. 퍼스트 인 퍼스트 아웃을 구현할 것이므로 pop(0)을 써야한다.
* **객체 이동:** 리스트에서 `pop`해서 다른 리스트에 `append`하면, 객체는 복사되는 게 아니라 **참조(주소)만 이동**한다. 즉, `ready_queue`에 있는 놈을 수정하면 원본도 수정된다. 

## 📅 11일 차: FCFS 스케줄러 구현

### 🎯 오늘의 목표
1. `Scheduler` 부모 클래스를 상속받아 `FCFSScheduler` 구현하기.
2. `deque`를 사용하여 FIFO(선착순) 로직이 잘 동작하는지 테스트하기.

### 📝 배운 점 (TIL)
* **상속(Inheritance):** 부모 클래스(`Scheduler`)에 공통 기능(`add_process`)을 두고, 자식 클래스(`FCFSScheduler`)에서 고유 기능(`get_next_process`)만 구현하니 코드가 깔끔하다.
* **Deque:** 큐를 구현할 때는 리스트보다 `collections.deque`가 성능상 유리하다는 것을 알았다.

## 📅 12일 차: CPU 로드와 문맥 교환 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 `load_process`를 구현하여 프로세스를 교체하는 로직 만들기.
2. 교체 시 `Context Switch` 로그가 정확히 찍히는지 확인하기.

### 📝 배운 점 (TIL)
* **문맥 교환의 실체:** 코드로 보니 별거 없어 보이지만(`current_process` 변수 바꾸기), 실제로는 여기서 레지스터 백업/복구 작업이 일어나며 시스템 자원을 소모한다는 것을 이해함.
* **Dispatcher:** 스케줄러가 '두뇌'라면, `load_process`를 수행하는 CPU(Dispatcher)는 '손발'이다.

## 📅 13일 차: 커널 메인 루프 구현

### 🎯 오늘의 목표
1. `while` 루프를 이용해 시간이 흐르는 구조 만들기.
2. `Global Time` 변수를 관리하고 로그에 찍기.

### 📝 배운 점 (TIL)
* **OS는 무한 루프다:** 운영체제는 `while True` 안에서 계속 상태를 체크하고 명령을 내리는 프로그램임
* **IDLE 상태:** 할 일이 없을 때도 루프는 계속 돈다. (이때 전기를 아끼기 위해 실제 CPU는 저전력 모드로 들어간다고 함.)

## 📅 14일 차: 프로세스 도착 시뮬레이션

### 🎯 오늘의 목표
1. `JOB_LIST`에 정의된 프로세스들이 제시간(`arrival_time`)에 맞춰 `Ready Queue`로 들어오게 한다.
2. `New -> Ready` 상태 변경을 명시적으로 처리한다.

### 📝 배운 점 (TIL)
* **리스트 순회 중 삭제:** `for p in JOB_LIST:` 도중에 `JOB_LIST.remove(p)`를 하면 인덱스 에러나 건너뜀 현상이 발생한다. `list(JOB_LIST)`로 복사본을 만들어서 돌리는 테크닉을 썼다.
* **상태 관리의 책임:** 스케줄러에 넣는다고 상태가 저절로 바뀌지 않는다. 개발자가 꼼꼼하게 챙겨야 한다.

### 💥 트러블 슈팅
* `ProcessState` import를 빼먹어서 에러 발생. -> 추가해서 해결.

## 📅 15일 차: 스케줄링 통합 (Dispatch Logic)

### 🎯 오늘의 목표
1. `main.py` 루프 안에서 `cpu.is_busy()`를 체크하여, 비어있을 때 스케줄러에서 프로세스를 가져오는 로직 구현.
2. `Ready -> Running` 상태 전이를 적절한 타이밍에 수행.

### 📝 배운 점 (TIL)
* **OS의 판단 순서:** 매 틱마다 [도착 확인] -> [CPU 상태 확인] -> [스케줄링] -> [실행] 순서로 로직이 흘러가야 자연스럽다.
* **좀비 프로세스:** 종료 조건이 없으니 프로세스가 죽지 않고 계속 실행되어 `Remaining Time`이 제로에서 계속 버티는 현상을 목격함. 종료 로직의 필요성 체감.

## 📅 16일 차: 프로세스 종료 처리 (Termination)

### 🎯 오늘의 목표
1. `cpu.run()` 직후 `remaining_time == 0`인지 검사하는 로직 추가.
2. 종료된 프로세스를 `TERMINATED` 상태로 변경하고 CPU를 비움(`None`).
3. 다음 틱에 대기 중이던 프로세스가 자동으로 실행되는지 확인.

### 📝 배운 점 (TIL)
* **스케줄링의 연속성:** 내가 수동으로 PID 2 실행하라고 명령하지 않아도, 종료 -> CPU 비움 -> 다음 루프 -> 스케줄러 호출의 흐름에 따라 다음 프로세스가 실행됨.
* **CPU Unload:** `cpu.current_process = None` 한 줄이 자원 반납의 핵심이었다.

## 📅 17일 차: 로깅 시스템 개선

### 🎯 오늘의 목표
1. 중구난방이던 로그 메시지의 포맷을 통일한다.
2. `IDLE` 상태일 때도 현재 시스템 상황(Ready Queue 크기 등)을 출력하게 한다.

### 📝 배운 점 (TIL)
* **로그의 가독성:** 로그는 나를 위한 것이다. 들여쓰기와 이모지만 잘 써도 디버깅 시간이 절반으로 줄어든다.
* **정보의 선별:** 너무 많은 정보는 소음이고, 너무 적은 정보는 무용지물이다. 딱 필요한 정보(PID, State, Queue Size)만 남기는 것이 기술이다.

## 📅 18일 차: FCFS 시나리오 테스트 (Convoy Effect)

### 🎯 오늘의 목표
1. 실행 시간이 긴 프로세스(P1)를 먼저 넣고, 짧은 프로세스(P2, P3)를 나중에 넣어본다.
2. P2, P3가 얼마나 오래 기다리는지 로그를 통해 확인한다.

### 📝 배운 점 (TIL)
* **Convoy Effect:** 1차선 도로의 똥차 효과를 시뮬레이터로 직접 목격했다. P2는 1초만 일하면 되는데, P1 때문에 10초를 기다렸다.
* **FCFS의 한계:** 일괄 처리 시스템(Batch System)에는 맞을지 몰라도, 대화형 시스템(Interactive System)에는 절대 쓰면 안 되겠다.

## 📅 19일 차: 대기 시간 계산 및 성적표 출력

### 🎯 오늘의 목표
1. 매 틱마다 `Ready Queue`에 있는 프로세스들의 `waiting_time`을 증가시킨다.
2. 종료 시점에 `Turnaround Time`을 계산한다.
3. 최종적으로 표(Table) 형태로 결과를 출력하여 FCFS의 비효율성을 수치로 증명한다.

### 📝 배운 점 (TIL)
* **실시간 누적법:** 대기 시간을 나중에 빼기로 계산하는 것보다, 매 순간 더해나가는 방식이 직관적이고 구현하기 쉬웠다.
* **데이터의 힘:** 로그만 볼 때는 "느리네" 정도였는데, 성적표를 보니 "평균 6초 vs 0.6초"라는 압도적인 차이가 보였다. 이것이 SJF가 필요한 이유다.

## 📅 21일 차: SJF 스케줄러 구현

### 🎯 오늘의 목표
1. `SJF_Scheduler` 클래스를 만들고 `get_next_process`에서 `burst_time`이 가장 작은 프로세스를 반환하도록 구현.
2. 동시에 도착한 프로세스들에 대해 FCFS와 SJF의 성능 차이를 비교.

### 📝 배운 점 (TIL)
* **SJF의 위력:** 짧은 작업을 먼저 처리하니 전체적인 대기 시간이 획기적으로 줄어든다.
* **비선점의 한계:** 하지만 이미 실행 중인 프로세스를 쫓아내진 못한다. 진정한 의미의 "짧은 놈 먼저"를 하려면 선점형이 필요하다.

## 📅 22일 차: SJF 성능 검증 (비선점형의 한계)

### 🎯 오늘의 목표
1. 도착 시간이 다른 시나리오에서 SJF가 어떻게 동작하는지 확인한다.
2. 짧은 프로세스(P2)가 늦게 도착했을 때, 긴 프로세스(P1)에게 밀려 대기하는 현상 관찰.

### 📝 배운 점 (TIL)
* **SJF != 만능:** SJF는 "Ready Queue에 있는 애들끼리"만 경쟁한다. 이미 Running 중인 애는 건드리지 못한다는걸 눈으로 직접 봤다.
* **선점(Preemption)의 필요성:** 진정한 효율성을 위해서는 늦게 도착했더라도 더 급한 놈이 있으면 실행 중인 놈을 쫓아내는 선점이 필요하다는 것을 절실히 느꼈다

## 📅 23일 차: SJF 기아 현상 (Starvation)

### 🎯 오늘의 목표
1. 짧은 프로세스들이 지속적으로 유입될 때, 긴 프로세스가 계속 뒤로 밀리는 현상을 재현한다.
2. 이를 위해 '미끼 프로세스'를 사용하여 긴 프로세스가 처음에 CPU를 잡지 못하게 유도하는 시나리오를 설계한다.

### 📝 배운 점 (TIL)
* **공정성(Fairness):** SJF는 효율성(평균 대기 시간)은 최고지만, 공정성은 최악이다.
* **시나리오 설계:** 비선점형 스케줄러에서 기아 현상을 테스트하려면, 처음에 CPU를 누군가 잡고 있어야 한다는 조건을 잘 맞춰야 한다.

### 💥 트러블 슈팅 
* **현상:** SJF 기아 현상 테스트 중, 긴 프로세스(PID 2)가 통계에서 아예 누락되어 평균 대기 시간이 `0.00`으로 나오는 현상 발생.
* **원인:** 통계 로직이 `finished_processes`(완료된 작업)만 대상으로 계산하기 때문. PID 2는 영원히 고통받거나 실행 중이라서 리스트에 포함되지 않음. 이는 **'생존자 편향(Survivorship Bias)'**과 유사함.
* **깨달음:** 
    1. 평가 지표에서, 평가 시스템이 만드는 edge case를 항상 조심해야 한다.
    2. SJF의 기아 현상은 단순히 "늦게 실행된다"가 아니라, **"시스템의 통계마저 왜곡할 수 있다"**는 점에서 더 무섭다.

## 📅 24일 차: 라운드 로빈(RR) 기초

### 🎯 오늘의 목표
1. `RoundRobin_Scheduler` 클래스 생성 및 `time_quantum` 설정.
2. 선점 로직이 없을 때 RR이 FCFS와 동일하게 동작함을 확인.

### 📝 배운 점 (TIL)
* **RR의 구조:** RR은 스케줄러 자체의 알고리즘보다, 커널(Main Loop)이 시간을 재고 강제로 뺏는(Preemption) 로직이 핵심이다.

## 📅 25일 차: 라운드 로빈 선점(Preemption) 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 현재 버스트 시간을 세는 `cpu_burst_counter` 추가.
2. `run_simulation`에서 `isinstance`를 사용해 RR 스케줄러일 때만 타임 아웃 로직 적용.
3. 타임 아웃 시 `RUNNING -> READY`로 상태 변경 후 다시 큐에 넣기.

### 📝 배운 점 (TIL)
* **Preemption의 원리:** 하드웨어(Timer)와 OS(Scheduler)가 합작하여 독점을 막는 과정을 코드로 구현했다. 
* **isinstance:** 파이썬에서 객체의 타입을 확인하여 특정 스케줄러일 때만 동작하게 하는 분기 처리가 유용했다.

## 📅 26일 차: 문맥 교환 오버헤드 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 `is_switching` 상태를 추가하여, 교체 시 1틱을 소모하게 만든다.
2. 오버헤드가 발생할 때 CPU가 유용한 작업(`tick`)을 하지 못하는 것을 확인한다.

### 📝 배운 점 (TIL)
* **공짜 점심은 없다:** 멀티태스킹은 CPU 시간을 갉아먹는 비용(Overhead)을 치르고 얻는 편의성이라는 것을 깨달았다.
* **상태 머신:** CPU 내부에도 `Running`과 `Switching`이라는 상태가 존재함을 구현했다.