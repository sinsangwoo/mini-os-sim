# 🛠️ Project PyOS 개발 일지

## 📅 7일 차: 프로세스 시각화 및 개발 일지 시작

### 🎯 오늘의 목표
1. `print(process)` 했을 때 상태가 한눈에 보이게 만들기 (`__repr__` 구현).
2. 개발 과정에서 겪은 시행착오 기록하기.

### 📝 배운 점 (TIL)
* `__str__`과 `__repr__`의 차이점: `__repr__`은 개발자용, 리스트 출력 시 사용됨.
* f-string의 정렬 기능: `f"{val:<10}"` 처럼 쓰면 칸을 맞출 수 있음.

### 💥 트러블 슈팅 (실패와 해결)
* 출력 결과의 세로 줄 어긋남 (정렬 이슈)
현상: 모든 프로세스의 정보가 출력되지만, 남은 시간(Remaining time)이 10인 경우와 5인 경우의 세로 위치가 맞지 않아 표가 삐뚤어짐.

원인: f-string 포맷팅 시 고정된 문자열(Remaining time:)과 가변적인 숫자(5, 10) 사이의 공백 처리가 불분명했기 때문임. 자릿수가 커질수록 숫자가 뒤로 밀리는 현상 발생.

해결: {:>2} 또는 {:>3}과 같은 포맷팅 규칙을 사용하여 **숫자가 들어갈 전용 칸**을 미리 확보함.

메커니즘: 숫자가 1자리든 2자리든 무조건 같은 칸(예: 3칸)을 차지하게 함으로써 뒤에 오는 구분선(|)의 위치를 고정시킴.

Python

수정 전
return f"Remaining time:{self.remaining_time:>2}]" 

수정 후 (공백과 칸 수를 명확히 지정)
return f"Remaining time: {self.remaining_time:>2}]"

💡 깨달은 점
코드에 문제가 없는데 작동하지 않을 때는 **환경(저장 상태, 실행 경로)**을 먼저 의심해 보자.
사용자나 개발자가 보는 데이터는 시각적 정렬이 매우 중요하며, 파이썬의 f-string 정렬 기능은 이를 위한 매우 강력한 도구이다.

## 📅 8일 차: 프로세스 공장 가동 

### 🎯 오늘의 목표
1. 반복문을 이용해 프로세스를 대량 생산하기.
2. `Job Queue`에서 `Ready Queue`로 프로세스를 이동시키는 로직 구현 

### 📝 배운 점 (TIL)
* **`pop(0)` vs `pop()`:** `pop()`은 맨 뒤(스택)에서 꺼내고, `pop(0)`은 맨 앞(큐)에서 꺼낸다. 퍼스트 인 퍼스트 아웃을 구현할 것이므로 pop(0)을 써야한다.
* **객체 이동:** 리스트에서 `pop`해서 다른 리스트에 `append`하면, 객체는 복사되는 게 아니라 **참조(주소)만 이동**한다. 즉, `ready_queue`에 있는 놈을 수정하면 원본도 수정된다. 

## 📅 11일 차: FCFS 스케줄러 구현

### 🎯 오늘의 목표
1. `Scheduler` 부모 클래스를 상속받아 `FCFSScheduler` 구현하기.
2. `deque`를 사용하여 FIFO(선착순) 로직이 잘 동작하는지 테스트하기.

### 📝 배운 점 (TIL)
* **상속(Inheritance):** 부모 클래스(`Scheduler`)에 공통 기능(`add_process`)을 두고, 자식 클래스(`FCFSScheduler`)에서 고유 기능(`get_next_process`)만 구현하니 코드가 깔끔하다.
* **Deque:** 큐를 구현할 때는 리스트보다 `collections.deque`가 성능상 유리하다는 것을 알았다.

## 📅 12일 차: CPU 로드와 문맥 교환 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 `load_process`를 구현하여 프로세스를 교체하는 로직 만들기.
2. 교체 시 `Context Switch` 로그가 정확히 찍히는지 확인하기.

### 📝 배운 점 (TIL)
* **문맥 교환의 실체:** 코드로 보니 별거 없어 보이지만(`current_process` 변수 바꾸기), 실제로는 여기서 레지스터 백업/복구 작업이 일어나며 시스템 자원을 소모한다는 것을 이해함.
* **Dispatcher:** 스케줄러가 '두뇌'라면, `load_process`를 수행하는 CPU(Dispatcher)는 '손발'이다.