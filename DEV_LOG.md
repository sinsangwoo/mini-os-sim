# 🛠️ Project PyOS 개발 일지

## 📅 7일 차: 프로세스 시각화 및 개발 일지 시작

### 🎯 오늘의 목표
1. `print(process)` 했을 때 상태가 한눈에 보이게 만들기 (`__repr__` 구현).
2. 개발 과정에서 겪은 시행착오 기록하기.

### 📝 배운 점 (TIL)
* `__str__`과 `__repr__`의 차이점: `__repr__`은 개발자용, 리스트 출력 시 사용됨.
* f-string의 정렬 기능: `f"{val:<10}"` 처럼 쓰면 칸을 맞출 수 있음.

### 💥 트러블 슈팅 (실패와 해결)
* 출력 결과의 세로 줄 어긋남 (정렬 이슈)
현상: 모든 프로세스의 정보가 출력되지만, 남은 시간(Remaining time)이 10인 경우와 5인 경우의 세로 위치가 맞지 않아 표가 삐뚤어짐.

원인: f-string 포맷팅 시 고정된 문자열(Remaining time:)과 가변적인 숫자(5, 10) 사이의 공백 처리가 불분명했기 때문임. 자릿수가 커질수록 숫자가 뒤로 밀리는 현상 발생.

해결: {:>2} 또는 {:>3}과 같은 포맷팅 규칙을 사용하여 **숫자가 들어갈 전용 칸**을 미리 확보함.

메커니즘: 숫자가 1자리든 2자리든 무조건 같은 칸(예: 3칸)을 차지하게 함으로써 뒤에 오는 구분선(|)의 위치를 고정시킴.

Python

수정 전
return f"Remaining time:{self.remaining_time:>2}]" 

수정 후 (공백과 칸 수를 명확히 지정)
return f"Remaining time: {self.remaining_time:>2}]"

💡 깨달은 점
코드에 문제가 없는데 작동하지 않을 때는 **환경(저장 상태, 실행 경로)**을 먼저 의심해 보자.
사용자나 개발자가 보는 데이터는 시각적 정렬이 매우 중요하며, 파이썬의 f-string 정렬 기능은 이를 위한 매우 강력한 도구이다.

## 📅 8일 차: 프로세스 공장 가동 

### 🎯 오늘의 목표
1. 반복문을 이용해 프로세스를 대량 생산하기.
2. `Job Queue`에서 `Ready Queue`로 프로세스를 이동시키는 로직 구현 

### 📝 배운 점 (TIL)
* **`pop(0)` vs `pop()`:** `pop()`은 맨 뒤(스택)에서 꺼내고, `pop(0)`은 맨 앞(큐)에서 꺼낸다. 퍼스트 인 퍼스트 아웃을 구현할 것이므로 pop(0)을 써야한다.
* **객체 이동:** 리스트에서 `pop`해서 다른 리스트에 `append`하면, 객체는 복사되는 게 아니라 **참조(주소)만 이동**한다. 즉, `ready_queue`에 있는 놈을 수정하면 원본도 수정된다. 

## 📅 11일 차: FCFS 스케줄러 구현

### 🎯 오늘의 목표
1. `Scheduler` 부모 클래스를 상속받아 `FCFSScheduler` 구현하기.
2. `deque`를 사용하여 FIFO(선착순) 로직이 잘 동작하는지 테스트하기.

### 📝 배운 점 (TIL)
* **상속(Inheritance):** 부모 클래스(`Scheduler`)에 공통 기능(`add_process`)을 두고, 자식 클래스(`FCFSScheduler`)에서 고유 기능(`get_next_process`)만 구현하니 코드가 깔끔하다.
* **Deque:** 큐를 구현할 때는 리스트보다 `collections.deque`가 성능상 유리하다는 것을 알았다.

## 📅 12일 차: CPU 로드와 문맥 교환 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 `load_process`를 구현하여 프로세스를 교체하는 로직 만들기.
2. 교체 시 `Context Switch` 로그가 정확히 찍히는지 확인하기.

### 📝 배운 점 (TIL)
* **문맥 교환의 실체:** 코드로 보니 별거 없어 보이지만(`current_process` 변수 바꾸기), 실제로는 여기서 레지스터 백업/복구 작업이 일어나며 시스템 자원을 소모한다는 것을 이해함.
* **Dispatcher:** 스케줄러가 '두뇌'라면, `load_process`를 수행하는 CPU(Dispatcher)는 '손발'이다.

## 📅 13일 차: 커널 메인 루프 구현

### 🎯 오늘의 목표
1. `while` 루프를 이용해 시간이 흐르는 구조 만들기.
2. `Global Time` 변수를 관리하고 로그에 찍기.

### 📝 배운 점 (TIL)
* **OS는 무한 루프다:** 운영체제는 `while True` 안에서 계속 상태를 체크하고 명령을 내리는 프로그램임
* **IDLE 상태:** 할 일이 없을 때도 루프는 계속 돈다. (이때 전기를 아끼기 위해 실제 CPU는 저전력 모드로 들어간다고 함.)

## 📅 14일 차: 프로세스 도착 시뮬레이션

### 🎯 오늘의 목표
1. `JOB_LIST`에 정의된 프로세스들이 제시간(`arrival_time`)에 맞춰 `Ready Queue`로 들어오게 한다.
2. `New -> Ready` 상태 변경을 명시적으로 처리한다.

### 📝 배운 점 (TIL)
* **리스트 순회 중 삭제:** `for p in JOB_LIST:` 도중에 `JOB_LIST.remove(p)`를 하면 인덱스 에러나 건너뜀 현상이 발생한다. `list(JOB_LIST)`로 복사본을 만들어서 돌리는 테크닉을 썼다.
* **상태 관리의 책임:** 스케줄러에 넣는다고 상태가 저절로 바뀌지 않는다. 개발자가 꼼꼼하게 챙겨야 한다.

### 💥 트러블 슈팅
* `ProcessState` import를 빼먹어서 에러 발생. -> 추가해서 해결.

## 📅 15일 차: 스케줄링 통합 (Dispatch Logic)

### 🎯 오늘의 목표
1. `main.py` 루프 안에서 `cpu.is_busy()`를 체크하여, 비어있을 때 스케줄러에서 프로세스를 가져오는 로직 구현.
2. `Ready -> Running` 상태 전이를 적절한 타이밍에 수행.

### 📝 배운 점 (TIL)
* **OS의 판단 순서:** 매 틱마다 [도착 확인] -> [CPU 상태 확인] -> [스케줄링] -> [실행] 순서로 로직이 흘러가야 자연스럽다.
* **좀비 프로세스:** 종료 조건이 없으니 프로세스가 죽지 않고 계속 실행되어 `Remaining Time`이 제로에서 계속 버티는 현상을 목격함. 종료 로직의 필요성 체감.

## 📅 16일 차: 프로세스 종료 처리 (Termination)

### 🎯 오늘의 목표
1. `cpu.run()` 직후 `remaining_time == 0`인지 검사하는 로직 추가.
2. 종료된 프로세스를 `TERMINATED` 상태로 변경하고 CPU를 비움(`None`).
3. 다음 틱에 대기 중이던 프로세스가 자동으로 실행되는지 확인.

### 📝 배운 점 (TIL)
* **스케줄링의 연속성:** 내가 수동으로 PID 2 실행하라고 명령하지 않아도, 종료 -> CPU 비움 -> 다음 루프 -> 스케줄러 호출의 흐름에 따라 다음 프로세스가 실행됨.
* **CPU Unload:** `cpu.current_process = None` 한 줄이 자원 반납의 핵심이었다.

## 📅 17일 차: 로깅 시스템 개선

### 🎯 오늘의 목표
1. 중구난방이던 로그 메시지의 포맷을 통일한다.
2. `IDLE` 상태일 때도 현재 시스템 상황(Ready Queue 크기 등)을 출력하게 한다.

### 📝 배운 점 (TIL)
* **로그의 가독성:** 로그는 나를 위한 것이다. 들여쓰기와 이모지만 잘 써도 디버깅 시간이 절반으로 줄어든다.
* **정보의 선별:** 너무 많은 정보는 소음이고, 너무 적은 정보는 무용지물이다. 딱 필요한 정보(PID, State, Queue Size)만 남기는 것이 기술이다.

## 📅 18일 차: FCFS 시나리오 테스트 (Convoy Effect)

### 🎯 오늘의 목표
1. 실행 시간이 긴 프로세스(P1)를 먼저 넣고, 짧은 프로세스(P2, P3)를 나중에 넣어본다.
2. P2, P3가 얼마나 오래 기다리는지 로그를 통해 확인한다.

### 📝 배운 점 (TIL)
* **Convoy Effect:** 1차선 도로의 똥차 효과를 시뮬레이터로 직접 목격했다. P2는 1초만 일하면 되는데, P1 때문에 10초를 기다렸다.
* **FCFS의 한계:** 일괄 처리 시스템(Batch System)에는 맞을지 몰라도, 대화형 시스템(Interactive System)에는 절대 쓰면 안 되겠다.

## 📅 19일 차: 대기 시간 계산 및 성적표 출력

### 🎯 오늘의 목표
1. 매 틱마다 `Ready Queue`에 있는 프로세스들의 `waiting_time`을 증가시킨다.
2. 종료 시점에 `Turnaround Time`을 계산한다.
3. 최종적으로 표(Table) 형태로 결과를 출력하여 FCFS의 비효율성을 수치로 증명한다.

### 📝 배운 점 (TIL)
* **실시간 누적법:** 대기 시간을 나중에 빼기로 계산하는 것보다, 매 순간 더해나가는 방식이 직관적이고 구현하기 쉬웠다.
* **데이터의 힘:** 로그만 볼 때는 "느리네" 정도였는데, 성적표를 보니 "평균 6초 vs 0.6초"라는 압도적인 차이가 보였다. 이것이 SJF가 필요한 이유다.

## 📅 21일 차: SJF 스케줄러 구현

### 🎯 오늘의 목표
1. `SJF_Scheduler` 클래스를 만들고 `get_next_process`에서 `burst_time`이 가장 작은 프로세스를 반환하도록 구현.
2. 동시에 도착한 프로세스들에 대해 FCFS와 SJF의 성능 차이를 비교.

### 📝 배운 점 (TIL)
* **SJF의 위력:** 짧은 작업을 먼저 처리하니 전체적인 대기 시간이 획기적으로 줄어든다.
* **비선점의 한계:** 하지만 이미 실행 중인 프로세스를 쫓아내진 못한다. 진정한 의미의 "짧은 놈 먼저"를 하려면 선점형이 필요하다.

## 📅 22일 차: SJF 성능 검증 (비선점형의 한계)

### 🎯 오늘의 목표
1. 도착 시간이 다른 시나리오에서 SJF가 어떻게 동작하는지 확인한다.
2. 짧은 프로세스(P2)가 늦게 도착했을 때, 긴 프로세스(P1)에게 밀려 대기하는 현상 관찰.

### 📝 배운 점 (TIL)
* **SJF != 만능:** SJF는 "Ready Queue에 있는 애들끼리"만 경쟁한다. 이미 Running 중인 애는 건드리지 못한다는걸 눈으로 직접 봤다.
* **선점(Preemption)의 필요성:** 진정한 효율성을 위해서는 늦게 도착했더라도 더 급한 놈이 있으면 실행 중인 놈을 쫓아내는 선점이 필요하다는 것을 절실히 느꼈다

## 📅 23일 차: SJF 기아 현상 (Starvation)

### 🎯 오늘의 목표
1. 짧은 프로세스들이 지속적으로 유입될 때, 긴 프로세스가 계속 뒤로 밀리는 현상을 재현한다.
2. 이를 위해 '미끼 프로세스'를 사용하여 긴 프로세스가 처음에 CPU를 잡지 못하게 유도하는 시나리오를 설계한다.

### 📝 배운 점 (TIL)
* **공정성(Fairness):** SJF는 효율성(평균 대기 시간)은 최고지만, 공정성은 최악이다.
* **시나리오 설계:** 비선점형 스케줄러에서 기아 현상을 테스트하려면, 처음에 CPU를 누군가 잡고 있어야 한다는 조건을 잘 맞춰야 한다.

### 💥 트러블 슈팅 
* **현상:** SJF 기아 현상 테스트 중, 긴 프로세스(PID 2)가 통계에서 아예 누락되어 평균 대기 시간이 `0.00`으로 나오는 현상 발생.
* **원인:** 통계 로직이 `finished_processes`(완료된 작업)만 대상으로 계산하기 때문. PID 2는 영원히 고통받거나 실행 중이라서 리스트에 포함되지 않음. 이는 **'생존자 편향(Survivorship Bias)'**과 유사함.
* **깨달음:** 
    1. 평가 지표에서, 평가 시스템이 만드는 edge case를 항상 조심해야 한다.
    2. SJF의 기아 현상은 단순히 "늦게 실행된다"가 아니라, **"시스템의 통계마저 왜곡할 수 있다"**는 점에서 더 무섭다.

## 📅 24일 차: 라운드 로빈(RR) 기초

### 🎯 오늘의 목표
1. `RoundRobin_Scheduler` 클래스 생성 및 `time_quantum` 설정.
2. 선점 로직이 없을 때 RR이 FCFS와 동일하게 동작함을 확인.

### 📝 배운 점 (TIL)
* **RR의 구조:** RR은 스케줄러 자체의 알고리즘보다, 커널(Main Loop)이 시간을 재고 강제로 뺏는(Preemption) 로직이 핵심이다.

## 📅 25일 차: 라운드 로빈 선점(Preemption) 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 현재 버스트 시간을 세는 `cpu_burst_counter` 추가.
2. `run_simulation`에서 `isinstance`를 사용해 RR 스케줄러일 때만 타임 아웃 로직 적용.
3. 타임 아웃 시 `RUNNING -> READY`로 상태 변경 후 다시 큐에 넣기.

### 📝 배운 점 (TIL)
* **Preemption의 원리:** 하드웨어(Timer)와 OS(Scheduler)가 합작하여 독점을 막는 과정을 코드로 구현했다. 
* **isinstance:** 파이썬에서 객체의 타입을 확인하여 특정 스케줄러일 때만 동작하게 하는 분기 처리가 유용했다.

## 📅 26일 차: 문맥 교환 오버헤드 구현

### 🎯 오늘의 목표
1. `CPU` 클래스에 `is_switching` 상태를 추가하여, 교체 시 1틱을 소모하게 만든다.
2. 오버헤드가 발생할 때 CPU가 유용한 작업(`tick`)을 하지 못하는 것을 확인한다.

### 📝 배운 점 (TIL)
* **공짜 점심은 없다:** 멀티태스킹은 CPU 시간을 갉아먹는 비용(Overhead)을 치르고 얻는 편의성이라는 것을 깨달았다.
* **상태 머신:** CPU 내부에도 `Running`과 `Switching`이라는 상태가 존재함을 구현했다.

## 📅 28일 차: 응답 시간(Response Time) 측정

### 🎯 오늘의 목표
1. 프로세스가 처음 실행되는 시점을 기록하여 `Response Time`을 계산한다.
2. 성적표에 응답 시간 항목을 추가하여 RR의 장점을 수치로 확인한다.

### 📝 배운 점 (TIL)
* **RR의 진가:** 대기 시간이나 반환 시간은 오버헤드 때문에 FCFS보다 나쁠 수 있지만, 응답 시간만큼은 압도적으로 좋다. 이것이 우리가 윈도우나 맥을 쓸 때 버벅거리지 않는 이유다.
* **지표의 다양성:** 성능을 평가하는 기준은 하나가 아니다. 목적(일괄 처리 vs 대화형)에 따라 중요한 지표가 다르다.

## 📅 29일 차: 우선순위 스케줄링 구현

### 🎯 오늘의 목표
1. `Process` 클래스에 `priority` 속성 추가.
2. `PriorityScheduler`를 구현하여 우선순위 기반으로 프로세스를 선택하는지 확인.

### 📝 배운 점 (TIL)
* **SJF는 Priority의 일종이다:** SJF는 `priority = burst_time`인 특수한 경우일 뿐, 로직은 완전히 동일하다는 것을 깨달았다.
* **유연성:** `key=lambda` 부분만 바꾸면 어떤 기준으로든 스케줄링을 할 수 있다.

## 📅 30일 차: 3단계(고급 스케줄링) 완료 및 회고

### 🎯 3단계 요약
FCFS의 한계를 극복하기 위해 SJF, RR, Priority 스케줄러를 구현하고 비교 분석함.

### 💡 핵심 인사이트 (Key Takeaways)
1. **Trade-off:** 모든 면에서 완벽한 스케줄러는 없다.
    * SJF는 효율적이지만 불공정하다.
    * RR은 공정하고 반응이 빠르지만 오버헤드가 크다.
2. **Context Switch:** 이론으로만 알던 문맥 교환 비용을 직접 구현해보니, 타임 퀀텀 설정이 왜 중요한지(너무 짧으면 오버헤드 심함) 체감했다.
3. **통계의 중요성:** "느낌"이 아니라 Waiting Time, Response Time 같은 "지표"로 성능을 증명하는 법을 배웠다.

### 🚀 다음 단계 (Phase 4)
이제 CPU 스케줄링은 마스터했다.
다음은 **메모리(Memory)**다.
프로세스가 실행되려면 메모리가 필요하다. 


## 📅 31일 차: 메모리 모델링 (RAM 구현)

### 🎯 오늘의 목표
1. `Memory` 클래스를 만들고 리스트를 이용해 물리 메모리를 구현한다.
2. `read`, `write` 메서드에서 주소 범위 검사를 수행한다.

### 📝 배운 점 (TIL)
* **메모리의 본질:** 하드웨어적으로 복잡해 보이는 메모리도, 소프트웨어 관점에서는 그저 인덱스로 접근 가능한 배열에 불과하다.

## 📅 32일 차: 페이징 기초 (프레임 관리)

### 🎯 오늘의 목표
1. `Memory` 클래스에 `PAGE_SIZE`와 `frames` 리스트를 추가한다.
2. 빈 프레임을 찾아서(`get_free_frame`) 할당하고(`set_frame`), 반납하는(`free_frame`) 로직을 구현한다.

### 📝 배운 점 (TIL)
* **프레임 테이블:** OS가 물리 메모리를 관리하는 장부다. 이게 없으면 누가 어디를 쓰고 있는지 알 길이 없다.
* **단위의 변화:** Byte 단위 접근은 CPU가 할 일이고, OS는 Frame 단위로 자원을 배분한다.

## 📅 33일 차: 페이지 테이블과 MMU 구현

### 🎯 오늘의 목표
1. `Process` 클래스에 `page_table` 딕셔너리를 추가하여 가상 주소 공간을 정의한다.
2. `MMU` 클래스를 만들고 `translate` 메서드를 통해 주소 변환 로직을 구현한다.

### 📝 배운 점 (TIL)
* **가상 메모리의 본질:** "가짜 주소(VA)"를 "진짜 주소(PA)"로 매핑해 주는 테이블 하나만 있으면, 수많은 프로세스가 서로의 영역을 침범하지 않고 메모리를 공유할 수 있다.

## 📅 34일 차: 메모리 할당자 (Memory Allocator) 구현

### 🎯 오늘의 목표
1. `MemoryManager` 클래스를 만들고 `allocate`, `deallocate` 메서드 구현.
2. 프로세스 도착 시 메모리를 할당하고, 종료 시 반납하는 로직을 `main.py`에 통합.

### 📝 배운 점 (TIL)
* **방 배정의 원리:** 빈 프레임을 찾아서 페이지 테이블에 적어주는 것이 할당의 전부다. 생각보다 단순하지만 강력하다.
* **OOM 처리:** 메모리가 없으면 프로세스를 시작조차 할 수 없다. (Admission Control)

## 📅 35일 차: 메모리 접근 시뮬레이션 (Load/Store)

### 🎯 오늘의 목표
1. `CPU` 클래스에 `mmu`를 연결하고, 랜덤하게 `LOAD`, `STORE` 명령을 수행하게 만든다.
2. `MMU`를 통해 주소 변환이 성공하고, 실제 메모리에 데이터가 저장되는지 로그로 확인한다.

### 📝 배운 점 (TIL)
* **CPU와 MMU의 관계:** CPU는 주소 변환을 위해 MMU라는 하드웨어에 전적으로 의존한다. MMU가 없으면 CPU는 맹인이나 다름없다.
* **명령어 사이클:** Fetch -> Decode -> Execute(Memory Access) -> Write Back의 과정을 아주 단순화해서 구현해 보았다.

### 💥 트러블 슈팅
* `CPU` 생성자 인자를 바꿨는데 `main.py`에서 수정 안 해서 에러 남. -> 수정 완료.

## 📅 36일 차: 페이지 폴트 (Page Fault) 기초

### 🎯 오늘의 목표
1. 페이지 테이블 구조를 `Valid Bit`를 포함하도록 확장한다.
2. `MMU`에서 `Valid=False`일 때 `Page Fault`를 발생시키고, `CPU`가 이를 감지하는지 확인한다.

### 📝 배운 점 (TIL)
* **Valid Bit의 위력:** 메모리 관리의 핵심은 "지금 당장 쓸 수 있는가?"를 판단하는 것이다.
* **하드웨어 지원:** 페이지 폴트는 소프트웨어만으로는 구현할 수 없다. MMU라는 하드웨어의 지원이 필수적이다.

### 💥 트러블 슈팅
* os가 수동할당했다고 가정한 테스트 코드 까먹고 안지워서 type error 발생. 수정함.


## 📅 37일 차: 페이지 교체 (FIFO) 구현 

### 🎯 오늘의 목표
1. 할당 순서 기록: MemoryManager에 fifo_queue를 도입하여, 어떤 페이지가 메모리에 먼저 들어왔는지 '선입선출(FIFO)' 순서를 기억한다.
2. 페이지 교체 실행: 새로운 프로세스가 들어올 자리가 없을 때, replace_page를 통해 가장 오래된 페이지를 쫓아내는 Swap Out 로직을 완성한다.

### 📝 배운 점 (TIL)
* **희생자 선정:** 누군가를 죽여야 내가 산다. fifo_queue에서 가장 먼저 들어온 페이지를 popleft()로 뽑아내어 빈 자리를 만드는 과정을 이해함.

* **Valid 비트 갱신:** 쫓겨난 페이지는 valid=False로 바꿔줘야 한다. 

* **메모리 기록의 중요성:** Memory 객체에 set_frame을 통해 실제 사용 중임을 마킹하지 않으면, OS가 빈 자리를 못 찾고 엉뚱한 로직을 수행하게 된다는 것을 배움.

### 💥 트러블 슈팅 
* 1. 데이터 구조 불일치 (TypeError)
문제: 페이지 테이블의 엔트리가 딕셔너리({'pfn': 0, ...})인데, 이를 숫자(int)처럼 다루려다 프로그램이 멈춤.
해결: entry['pfn']으로 실제 프레임 번호만 정확히 추출하도록 수정. 

* 2. 자승자박 OOM (Logic Error)
문제: 4개의 프레임을 할당받는 도중, 자기가 방금 채운 프레임 때문에 "빈 공간이 없다"고 판단하여 스스로 중단됨.
해결: 빈 공간이 없으면 그 즉시 교체 로직(replace_page)을 호출하여 자리를 만들며 진행하도록 allocate 함수의 흐름을 개선함.

## 📅 38일 차: 페이지 교체 (LRU) 구현

### 🎯 오늘의 목표
1. 페이지 테이블에 `last_access` 필드를 추가하고, `MMU`가 접근할 때마다 갱신한다.
2. `replace_page_lru` 메서드에서 가장 오래된 페이지를 찾아 쫓아낸다.

### 📝 배운 점 (TIL)
* **LRU의 구현 난이도:** FIFO는 큐 하나면 되지만, LRU는 모든 페이지의 시간을 추적해야 해서 비용이 많이 든다.
* **전역 정보의 필요성:** 교체 알고리즘은 "누가 메모리에 있는지"를 다 알아야 하므로, 프로세스 리스트 전체에 접근할 수 있어야 한다.

### 💥 트러블 슈팅
* 코드 정리를 안하고 계속 추가만 했더니 코드가 꼬여서 통째로 갈아엎음

## 📅 39일 차: 페이지 폴트 처리 (Block 로직)

### 🎯 오늘의 목표
1. `CPU`에서 메모리 접근 실패 시 `page_fault_flag`를 세운다.
2. `main.py`에서 이 깃발을 확인하면, 해당 프로세스를 강제로 `WAITING` 상태로 만들고 CPU에서 끌어내린다.

### 📝 배운 점 (TIL)
* **예외 처리의 흐름:** 하드웨어(CPU/MMU)가 문제를 감지하고 깃발을 들면, 소프트웨어(OS)가 이를 보고 스케줄링을 개입하는 **인터럽트 기반 구조**를 완벽히 이해했다.
* **상태 전이의 중요성:** 1단계에서 꼼꼼하게 만들어둔 `ProcessState.WAITING` 상태가 드디어 제 역할을 하기 시작했다.

### 💥 트러블 슈팅
* (없음) 38일 차의 꼬인 코드를 푼 덕분에 로직 추가가 수월했다.

## 📅 40일 차: 4단계(가상 메모리) 완료 및 메모리 시각화

### 🎯 4단계 요약
물리 메모리(RAM)를 모델링하고, 페이징 기법을 도입하여 MMU를 통한 주소 변환, Page Fault 예외 처리, 그리고 LRU 페이지 교체 알고리즘까지 구현함.

### 💡 핵심 인사이트 (Key Takeaways)
1. **가상화:** 프로세스는 자신이 메모리를 독점한다고 믿지만, 뒤에서는 MMU와 OS가 쉴 새 없이 주소를 바꿔치기하고 빈 공간을 찾아 헤매고 있었다.
2. **자원의 한계와 교체:** 메모리가 부족할 때 발생하는 `Swap Out`과 `Page Fault` 로직을 짜보며, 왜 램이 부족하면 컴퓨터가 급격히 느려지는지(Thrashing) 원리를 깨달았다.
3. **시각화의 힘:** `[P1] [P1] [  ]` 처럼 간단한 ASCII 맵만으로도 시스템의 상태를 파악하는 데 엄청난 도움이 되었다.

### 🚀 다음 단계 (Phase 5)
스케줄링(CPU)과 페이징(Memory)을 모두 정복했다.
하지만 프로세스는 계산만 하지 않는다. 키보드 입력도 받고 파일도 읽어야 한다.
다음은 **시스템 콜(System Call)과 I/O 블로킹**이다.
가장 현실적인 OS의 모습을 갖춰보자!